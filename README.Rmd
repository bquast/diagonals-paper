---
author:
  - name: Bastiaan Quast
    affiliation: The Graduate Institute, Geneva
    address: >
      Maison de la paix
      Geneva, Switzerland
    email: bquast@gmail.com
    url: http://qua.st/
title:
  formatted: "\\pkg{diagonals}: Fat Diagonals in R\\thanks{This research was financed by the Swiss National Science Foundation (SNSF) under the grant 'Development Aid and Social Dynamics' (100018-140745) administered by the Graduate Institute's Centre on Conflict, Development and Peacebuilding (CCDP) and led by Jean-Louis Arcand. We thank Sandra Reimann and Oliver Jutersonke at the CCDP for their generous support.}"
  plain:     "diagonals: Fat Diagonals in R"
  short:     "\\pkg{diagonals}: Fat Diagonals in R"
abstract: >
  The diagonals package implements functions for handling fat diagonal matrices, such as those that occur when multiple dimensions are mapped along one edge of a matrix.
keywords:
  # at least one keyword must be supplied
  formatted: [matrix, diagonal, block, "\\proglang{R}"]
  plain:     [matrix, diagonal, block, R]
preamble: >
  \usepackage{amsmath}
output: rticles::jss_article
bibliography: citations.bib
---


# Introduction

Diagonals are an important matrix manipulation.
We present the `diagonals` R package, which implements functions for dealing with **fat diagonals**.
Fat diagonals are block matrix-diagonals that occur when two or more dimensions are mapped along a single edge of a matrix.
For an asymmetric network graph (e.g. a dyadic social network) to be mapped to a matrix, we would need each node along each edge of matrix,
however we would also need to map the direction of the tie, which is an additional dimension.
Typically these would be represented as higher-order arrays (i.e. >= 3).
In order to effectively visualise such arrays, it can be helpful to do so in a matrix.
This could for instance be represented as in the following matrix (where the `i` and `o` suffices represent incoming and outgoing respectively). 

```{r, echo=FALSE}
M <- matrix(c(1,0,1,1,1,1,0,0,0,1,0,1,0,1,0,0,1,0,1,1,0,1,1,1,1,0,0,1,0,1,0,1), 
            nrow = 4, 
            ncol = 8, 
            dimnames = list(c("A", "B", "C", "D"),
                            c("Ai", "Ao", "Bi", "Bo", "Ci", "Co", "Di", "Do")
                            )
            )
m <- M
m
```

Sometimes the ties of a node to itself are not particularly meaningful (e.g. feeling of amiability towards oneself) and can be removed.
For a symmetric network this can simply be done using the function `diag()` in R's `base` package, e.g.

```{r}
sm <- matrix(1, nrow=4, ncol=4,
             dimnames = list(c("A","B","C","D"),c("A","B","C","D")))
diag(sm) <- NA
sm
```

However, for higher-order matrices this does not work well, since the diagonal follows the shortest dimension.

```{r}
diag(m) <- NA
m
```

In comes the `diagonals` package and its workhorse `fatdiag()` function.
The function is designed to mimic the behaviour of the `diag()` as closely as possible,
but with then for **fat diagonals**.

```{r, message=FALSE}
library(diagonals)
```

```{r echo=FALSE}
# restore m
m <- M
```

```{r}
# the matrix m was restored to its original state
fatdiag(m, steps=4) <- NA
m
```

These fat diagonal matrices can be thought of a a general version of a block diagonal matrix [see @rowland2007block]

Note that the `steps` argument defines the number of steps on the diagonal ladder.
Alternatively we could set the `size` of the step, more on this later.

The functions is this package where originally written in order to support the `gvc` package,
which implements a collection of trade-flow indicators.

In trade flows use Inter-Country Input Output tables (ICIOs),
which map every `country * industry` combination along both edges of the matrix.
These tables are used to compute the Leontief inverse [@leontief1936quantitative].
In order to make the value of the Leontief internally comparable we can normalise the inverse using post multiplication.
Generally, this post multiplication is done using a country's own exports, final demand, etc.
and since the `country * industry` dimensions are on each edge, this gives us a higher-order matrix for which we want to extrac the diagonal.


# Design

The implementation of fat diagonals in the `diagonals` package is intended to be as close as possible to the functions dealing with diagonals included in the `base` package.
As such, the package includes two functions.

- `fatdiag()`
- `fatdiag()<-`

These functions offer a very similar syntax to the base functions:

- `diag()`
- `diag()<-`

With the exception that the fat diagonal functions generally need more information in terms of the number of `steps` on the diagonal ladder, or the `size` of these steps.

The function `fatdiag<-` like its base package equivalent replaces the (fat) diagonal of its first argument `x` with the right side argument `value`.
The `value` argument can either be a scalar, in which case it is recycled for the length of the diagonal,
or it can be vector.
For the base package function `diag()<-` this vector has be of the same length as the diagonal (here, the shortest dimension of the matrix),
however, the `fatdiag()<-` function will accept any vector that is of a length that is an integer divisor of the length of the diagonal.
For example, if the length of the diagonal is `12`, then the follow lengths for the replacement vector are accepted: `1`, `2`, `3`, `4`, and `6`.

The `fatdiag` function act similar to the `diag()` function.
Both these functions have two main applications .
The first application is (fat) diagonal extraction, is the first argument `x` is a matrix, i.e. `length(dim(x)) == 2`,
then the function extracts the diagonal matrix and returns it as a vector.

The second application is (fat) diagonal matrix creation.
This can be done in two ways, using a scalar, or using a vector.
If a scalar is used for `x`, the `diag()` function returns an identity matrix `Ix`,
i.e. a matrix of dimensions `x` times `x` is returned, with `1` on the diagonal positions and `0` elsewhere.
The `fatdiag()` function supports the creation of non-square matrices (e.g. using `size = c(3,2)`)
and therefore uses `x` as the longest dimension of the matrix,
where the other dimension is determined automatically using the `size` argument.


# Usage

In the introduction we briefly demonstrate the usage of the `fatdiag()` function for assigning a new `value` to the fat diagonal.
Here we take a closer look at some of the additional functionality that is implemented.

```{r}
fatdiag(m, size=c(1,2) ) <- 881:888
m
```

So far we have been using the set `fatdiag()`, i.e. `fatdiag()<-`.
However, we can also use the `fatdiag()` function either for diagonal extraction, or diagonal matrix creation.

```{r}
fatdiag(m, steps = 4)
```

Fat diagonal matrices can be created using a scalar:

```{r}
fatdiag(9, steps=3)
```

or using a vector:

```{r}
fatdiag(1:27, steps=3)
```

We can extract a fat diagonal and diagonalise it again.

```{r}
m <- matrix(801:881, nrow=9, ncol=9)
fatdiag( fatdiag(m, steps=3), steps=3)
```

Note that the above code combines the two different ways in which the `fatdiag()` function can be used,
the interior iteration extracts the fat diagonal from the matrix `m` and returns it as a vector,
the exterior iteration takes the vector returned by the interior iteration and diagonalises it in a matrix, which is returned.


# Conclusion

Higher-order arrays can sometimes be mapped to a matrix, which enables us to visualise these arrays in a intuitive manner.
However, the standard matrix manipulations relating to diagonals become more complex when we do so.
The `diagonals` package provides the `fatdiag()` function family, which enables the manipulation of fat diagonals in `R`,
using a syntax that is very close to the `diag()` function family from `R`s `base` package.

# References
